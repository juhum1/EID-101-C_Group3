### Group 3 Cumulative Report (Julie Hum, Luke McConnell, Katharine Moncrieffe)
Link to GitHub repo: https://github.com/juhum1/EID-101-C_Group3/

## Mechanical
For the mechanical design tasks, we started with a quickly assembled cardboard chassis onto which all of the components were screwed in place. This chassis had a few problems: it placed the Arduinoâ€™s USB port in an inconvenient place, it was too back-heavy and too small to accommodate all of the necessary sensors. It was also flimsy and aesthetically unappealing. We used these flaws we noticed while working with the initial chassis to come up with a more refined design which comprises an acrylic laser-cut chassis and a 3D-printed mount for the motors and sensors. We used OnShape and AutoCAD to create the necessary CAD files. Even after the laser cut chassis was completed, we ran into issues with sizing, as the body of the robot was just slightly too big, which required us to redo the laser cut with a modified design.

## Electrical
Using the schematic as a guide, we aimed to make our wiring as neat as possible to improve the ease of debugging for later tasks. We tried to group together the wires for the sensors, which each have ground, power and signal wires, and the wires for the enablers and input pins of the motor controller, because those were relatively simple to follow. We taped the wires together to keep them out of the way so it was easier to focus on everything else. It was difficult to figure out which pins were appropriate to use for what purpose; for example, we ran into issues trying to use certain pins for the sensors or for the IMU because the readings would be different from what we expected. However, after we changed the pin we used, we didn't have any more problems.  

## Motion
For motion 1, we encountered a similar issue to the one we had with line following 2, where the car was unable to move in a straight line because of the disparity in the speeds of the motors. Our logic is still the same as it was for design sprint 2: using the dimensions of the wheel, we found the encoder pulses per 1m and used that to calculate the distance. Because of this, in our clip you can see that the car goes the same distance (1m) with each cycle, but it goes in an arc. 

For motion 2, we used the IMU to control the turning (yaw) angle of the car. We wrote a rotate() function to make the car turn to a specified angle, and our loop() is intended to turn the car 90 degrees and back in both the clockwise and counterclockwise directions. In completing this task, an issue that we ran into was with our motor, because some of the teeth of the motor were broken and causing turns to come out differently than expected. We figured out that the motor was spinning faster on one side, and this was confirmed when we opened it up to look inside and saw the teeth broken. We eventually replaced the motor using an unbroken one from 725. 

For motion 3, we used the ultrasonic sensor to measure the distance between the car and an obstacle, like a wall. We used the HC_SRO4_async library to read the distance to an obstacle, and with that information, we implemented motion control in our loop(). Our code moves the car forward and continuously measures the distance to the wall, and it stops if the wall is closer than a certain distance (DESIRED_DISTANCE_CM). We also print the measured distance to the serial monitor. 

## Line Following
We finished line following task B as part of the 2 required design sprints. Although there were challenges with completing our initial line following sprint where we followed a straight line, they were mainly hardware-related, and were solved by moving the sensors closer to the line, since we noticed that the sensors were picking up the light reflected off our ball caster and other parts outside of the course itself. After our initial line following sprint, we began testing our code on course B, but our car was turning in the opposite direction of the line. We determined that this was an issue with our sensor logic, so after fixing that by revisiting our truth table, we were able to complete line following task B with minimal other changes or improvements.

We also had to implement an LED visual indicator for course completion. We were concerned that it wouldn't fit on the car, because we knew that the actual wiring wasn't a problem but there wasn't space for a full-sized breadboard on our chassis with the Arduino and all the wires coming off it. We eventually chose to solder an LED to one of the wires on the car, because then we wouldn't have to make space for a breadboard or remove the LED circuit when it's no longer necessary. 

For line following task A, we struggled with making our motors run at the same speed to allow the car to move in a straight line. We discovered that one of our motors had a broken gear inside, and when we replaced it with a new motor from 725 we weren't able to set the duty cycle of the motor because it only ran at a single speed. To be specific, one motor only runs above 140 pwm, while the other motor doesn't match its speed even when we set the speed to 140+220 pwm. This caused our car to spin in circles because the motors couldn't be balanced to make their speeds match. Despite this, our line following logic should work, and we believe that the motors are the only issue right now. 

## Programming
Programming 1. In designing and writing our library, our first challenge was determining which functions were relevant and deserved to be included. We decided to have fields corresponding to the number of sensors and the pins that each sensor was connected to, which would be helpful in the event that someone had multiple sensor arrays and wanted to make multiple instances of our library. We decided that there should be a constructor to populate the fields of each instance as well as functions to control turning the pinModes of the sensor pins to INPUT, updating the array, and printing values from it. 

After deciding on the functionalities to be covered by our library, our next step was to translate these ideas into code. One issue that came up was including Arduino.h in ReflectiveLightArray.cpp. Because our begin() function relied on pinMode() to set the pinModes of each sensor pin to INPUT, but the code for our library isn't a .ino file, we kept running into compilation errors when we tried to call pinMode(). After some research, we figured out that we had to include Arduino.h to be able to use functions relevant to the Arduino like pinMode(). This is seen in our design journals: "Figured out that compilation issues occured when Arduino.h was not included."

For our state machines, the logic shown in our PDFs was implemented in the line following tasks (the first state machine) and in motion 3 (the second state machine). 

Our first state machine has 8 states. State 0 is intended to be where we read sensor output as an array of values [left IR value, middle IR value, right IR value]. Although we ended up using more IR sensors, our logic was similar, where we move to different states based on whether or not the sensors can read that they're over the line or not. Based on the values in the array, we either move forward (State 1, 7, 4) or turn left (State 2, 5) or turn right (State 3, 6), or stop (State 8). States 1-8 immediately lead back to checking the sensor outputs, and based on the values in our array we move to a different state if the motors aren't stopped. 

Our second state machine was much simpler, with only 2 states. Once we enter the loop(), we move the car forward and keep checking the distance with the ultrasonic sensor. When the distance to the obstacle is less than DESIRED_DISTANCE_CM, then we stop the motors. 

## Management
Management 1. Sub-problems: selecting sensor setup and designing speed control

For each of our sub-problems, we met as a group to discuss what our options were and what would be the best choice given the constraints on the size of the car and the difficulty of implementation, among other criteria. Initially it was difficult to think of enough options for each subproblem, which was problematic for the sensor selection subproblem in particular because using too many sensors can cause problems for the design of our sensor array and might make our car larger than the specified dimensions, but eventually we were able to find other options through research and comparing our car to online examples. 

This is reflected in our design journals from November 20 and November 25, which state, "We met as a group to discuss the sensor configuration and selection of sensors, and we decided on using 5 IR sensors as well as the ultrasonic and lidar sensors." and "We discussed how to tackle speed control as a group, and decided on using one encoder based on our design matrix for this subproblem."

2. Our proposed Gaant Chart was very different compared to what happened in reality, because we didn't expect how much work would get done in the design sprints and how many tasks "went together" - for example, designing and CADing the sensor array was much easier after the chassis was completed because those two parts are intended to go together. In the end, our actual work timeline diverged significantly from our proposed one. Our first Gantt Chart is found in our midterm presentation. 

3. Our BOM was similar to the one we showed in our Midterm Presentation because we chose not to use our budget on outside parts. 
